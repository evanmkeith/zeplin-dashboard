{
  "version": 3,
  "sources": ["../../yocto-queue/index.js", "../../p-limit/index.js"],
  "sourcesContent": ["/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n", "import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, args) => {\n\t\tqueue.enqueue(run.bind(undefined, fn, resolve, args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n"],
  "mappings": ";;;;;;;;;AAKA,IAAM,OAAN,MAAW;AAAA,EAIV,YAAY,OAAO;AAHnB;AACA;AAGC,SAAK,QAAQ;AAAA,EACd;AACD;AAZA;AAcA,IAAqB,QAArB,MAA2B;AAAA,EAK1B,cAAc;AAJd;AACA;AACA;AAGC,SAAK,MAAM;AAAA,EACZ;AAAA,EAEA,QAAQ,OAAO;AACd,UAAM,OAAO,IAAI,KAAK,KAAK;AAE3B,QAAI,mBAAK,QAAO;AACf,yBAAK,OAAM,OAAO;AAClB,yBAAK,OAAQ;AAAA,IACd,OAAO;AACN,yBAAK,OAAQ;AACb,yBAAK,OAAQ;AAAA,IACd;AAEA,2BAAK,OAAL;AAAA,EACD;AAAA,EAEA,UAAU;AACT,UAAM,UAAU,mBAAK;AACrB,QAAI,CAAC,SAAS;AACb;AAAA,IACD;AAEA,uBAAK,OAAQ,mBAAK,OAAM;AACxB,2BAAK,OAAL;AACA,WAAO,QAAQ;AAAA,EAChB;AAAA,EAEA,QAAQ;AACP,uBAAK,OAAQ;AACb,uBAAK,OAAQ;AACb,uBAAK,OAAQ;AAAA,EACd;AAAA,EAEA,IAAI,OAAO;AACV,WAAO,mBAAK;AAAA,EACb;AAAA,EAEA,EAAG,OAAO,YAAY;AACrB,QAAI,UAAU,mBAAK;AAEnB,WAAO,SAAS;AACf,YAAM,QAAQ;AACd,gBAAU,QAAQ;AAAA,IACnB;AAAA,EACD;AACD;AAnDC;AACA;AACA;;;ACfc,SAAR,OAAwB,aAAa;AAC3C,MAAI,GAAG,OAAO,UAAU,WAAW,KAAK,gBAAgB,OAAO,sBAAsB,cAAc,IAAI;AACtG,UAAM,IAAI,UAAU,qDAAqD;AAAA,EAC1E;AAEA,QAAM,QAAQ,IAAI,MAAM;AACxB,MAAI,cAAc;AAElB,QAAM,OAAO,MAAM;AAClB;AAEA,QAAI,MAAM,OAAO,GAAG;AACnB,YAAM,QAAQ,EAAE;AAAA,IACjB;AAAA,EACD;AAEA,QAAM,MAAM,OAAO,IAAI,SAAS,SAAS;AACxC;AAEA,UAAM,UAAU,YAAY,GAAG,GAAG,IAAI,GAAG;AAEzC,YAAQ,MAAM;AAEd,QAAI;AACH,YAAM;AAAA,IACP,QAAE;AAAA,IAAO;AAET,SAAK;AAAA,EACN;AAEA,QAAM,UAAU,CAAC,IAAI,SAAS,SAAS;AACtC,UAAM,QAAQ,IAAI,KAAK,QAAW,IAAI,SAAS,IAAI,CAAC;AAEpD,KAAC,YAAY;AAKZ,YAAM,QAAQ,QAAQ;AAEtB,UAAI,cAAc,eAAe,MAAM,OAAO,GAAG;AAChD,cAAM,QAAQ,EAAE;AAAA,MACjB;AAAA,IACD,GAAG;AAAA,EACJ;AAEA,QAAM,YAAY,CAAC,OAAO,SAAS,IAAI,QAAQ,aAAW;AACzD,YAAQ,IAAI,SAAS,IAAI;AAAA,EAC1B,CAAC;AAED,SAAO,iBAAiB,WAAW;AAAA,IAClC,aAAa;AAAA,MACZ,KAAK,MAAM;AAAA,IACZ;AAAA,IACA,cAAc;AAAA,MACb,KAAK,MAAM,MAAM;AAAA,IAClB;AAAA,IACA,YAAY;AAAA,MACX,OAAO,MAAM;AACZ,cAAM,MAAM;AAAA,MACb;AAAA,IACD;AAAA,EACD,CAAC;AAED,SAAO;AACR;",
  "names": []
}
